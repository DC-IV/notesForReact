#### Заглянувший помни, данный конспект стоит рассматривать только в рамках курса ["React JS - путь самурая"](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8). Ну и конечно же "вжух-вжух-вжух самураи !!!".
## Особенности React
  Ключевые особенности React: декларативность, универсальность, компонентный подход, виртуальный DOM, JSX.
## Компонент
- это **функция**, возвращающая разметку `JSX` и принимающая параметры `props`:
```jsx
const App = () => {
  return (
    <div>
      какая-то разметка
    </div>
  )
}
```  
- самостоятельно никогда не вызывается, вставляется с помощью тега:
```jsx
<App />
```
> Компонент всегда должен называться с большой буквы.

## import/export
При импорте javascript файлов, расширение писать не обязательно:
```jsx
import App from './App';
```
  При импорте других файлов, писать обязательно:
```jsx
import './App.css';
```
> Для того чтобы что-то импортировать, это должно быть экспортировано.  

По дефолту экспортируется только одна функция:
```jsx
export default App;
```
> При импорте модулей, не указывается путь, а только лишь название этого модуля в кавычках, например:
```jsx
import React from 'react';
import ReactDOM from 'react-dom';
```
  Название импортуемой фунции из файла по сути является переменной и может иметь произвольное наименование, которое может не совпадать с названием экспортируемой функции **по дефолту** в файле импорта. Например:
```jsx
import Abrakadabra from "./Technologies";

{/* СОДЕРЖИМОЕ ФАЙЛА TECHNOLOGIES.JS */}

const Technologies = () => {
    return <div>Какой-то текст</div>;
};

export default Technologies;
```
  Переменной `Abrakadabra` будет присвоено содержимое экспортируемое из файла `Technologies.js`. Также функция возвращает только один корневой `<div>`, исключение составляет использование модуля `<ReactFragment>` в которое оборачивается все содержимое `return()`.
  В одном компоненте могут одновременно экспортироваться несколько функций. При этом **по дефолту** экспортироваться может только одна. Остальные эскпортируются без ключевого слова `default`.
```jsx
const Foo = () => {
    return <div>Какой-то текст</div>;
};

const Bar = () => {
    return <div>Какой-то текст</div>;
};

export Foo;
export default Bar;
```
  В компоненте где такой компонент импортируется, следует использовать фигурные скобки `{}`, для функции которая не экспортируется по дефолту. Также таких функций может быть несколько, тогда стоит их перечилять через запятую в рамках одних фигурных скобок `import { BrowserRouter, Switch, Route } from "react-router-dom"`. Из одного компонента могут одновременно импортироваться фукнции как по дефолту так и нет. Пример: 
```jsx
import React, { Fragment, useContext } from "react";
```
  В данном примере компонент `React` экспортируется из `react` по дефолту, поэтому он вне фигурных скобок и может иметь произвольное наименование. А вот компоненты `Fragment, useContext` по дефолту не экспортируются, поэтому заключены в фигурные скобки, перечислены через запятую, а названия должны совпадать с названиями экспортируемых функций.

## Стили
  Импорт стилей производится по тому же правилу что и импорт компонентов, за исключением того, что из файла стилей экспортировать ничего не нужно.
```jsx
import "./App.css";
```
  В реакте чаще всего используются модули стилей. Для их использования необходимо в расширение файлов добавить префикс `module`. Например: `App.module.css`. При отсутсвии стилей использующих классы, а также если они не используются в компоненте где эти стили импортируются, импорт будет таким же, как и обычных стилей.
```jsx
import "./App.module.css";
```
#### Использование классов
  Классы в таких стилях имеют разные области видимости и никак не пересекаются, а на странице сайта они имеют префиксы, например класс `QuizList` на странице будет иметь вид `QuizList_QuizList__FdDtE`. Для использования классов в модульных стилях, необходимо задавать переменную наподобие той что мы задаем при импорте компонентов. Обзепринятым правилом является использование слова `classes`.
```jsx
import classes from "./App.module.css";
```
На странице компонента классы теперь необходимо задавать в фигурных скобках `{}`, а не в кавычках `""` как раньше. Классы задаются на странице компонента, элементам возвращаемой разметки, а не на странице вызова этого компонента. Например:
```jsx
render() {
  return (
    <div className={classes.Quiz}>
      Какое-то содержимое...
    </div>
  );
}
```
  Для использования препроцессоров, например `Sass`, необходимо установить `npm` пакет: `npm install node-sass`, а в расширения css файлов добавить расширение используемого препроцессора, например: `./App.module.scss`.
  > Не стоит забывать что `Class` в javascript является зарезервированным словом и не может использоваться для задания классов элементам, вместо него стоит использовать слово `className`.

## Props
Каждая компонента вызывается с параметрами (props). Пропс это объект параметров.
```jsx
const Header = (props) => {
  return (
    <div>
    Какое-то содержимое...
    </div>
  )
}
```
> Существует общепринятое соглашение о именовании параметров **пропсами**.  

  Реакт всегда вставляет какой-то объект в качестве пропса, в том числе пустой.
```jsx
let obj = {
  name: 'Dima'
}

Header(obj);
```
  Когда используем тег (компонент), внутрь тега по умолчанию попадает пустой пропс (объект с параметрами).
```jsx
<Header />

{
// empty object
}
```
  Наш компонент тоже является тегом, а значит мы тоже можем его настраивать извне с помощью атрибутов. Реакт автоматически создаст объект с ключом равным имени атрибута и значением равным значению атрибута. И к нам в тег попадет уже не пустой пропс, а со значением. Количество атрибутов переданных в компонент равняется количеству объектов в `props`.
```jsx
<Header name='Dima K' age='30' />

{
  name: 'Name K',
  age: '30'
}
```
  И наш тег получает доступ к пропсам. Посредством синтаксиса `props.name`.
```jsx
const Header = (props) => {
  console.log(props);

  return (
    <span> {props.name}, {props.age} </span>
  )
}
```
  Для обращения к объекту javascript внутри jsx (внутри конструкции `return()`), необходимо использовать фигурные скобки `{}`. Если же писать javascript до `return()`, то фигурные скобки писать не нужно, например: `console.log(props)`.  

## Роутинг
```bash
npm install react-router-dom
```
```jsx
import { BrowserRouter, Route } from 'react-router-dom'
```
  Некоторая система которая следит за адресом, реагирует на его изменения и загружать нужный компонент. Вместо обычного компонента будет использоваться компонент `<Route />`. Обязательными атрибутами являются `component`, где в качестве значения которого указывается компонент страницы, и `path` в котором указывается путь до компонента. Для использования роутинга необходимо весь возвращаемый `JSX` обернуть в `<BrowserRouter />`.
```jsx
const App = (props) => {
  return (
    <BrowserRouter>
      <div className='app-wrapper'>
        <Header />
        <Navbar />
        <div className='app-wrapper-content'>
          <Route path='/dialogs' component={ Dialogs } />
          <Route path='/profile' component={ Profile } />
        </div>
      </div>
    </BrowserRouter>
  )
}
```
  В случае передачи названия функции компонента в качестве значения атрибута `component`, передать `props` не представляется возможным. Вместо этого в качестве значения стоит передавать не название **функции компонента** `Dialogs`, а **анонимную стрелочную функцию** `() => {}`, с вызовом **тега компонента** `<Dialogs />`.
```jsx
<Route path='/dialogs' component={ () => <Dialogs /> } />
```
  Теперь в компонент можно передавать атрибуты (параметры (props)). Взамен атрибута `component` предпочтительнее использовать `render`.
```jsx
<Route path='/dialogs' component={ () => <Dialogs /> } />
```
Aтрибуты `component` и `render` нельзя использовать одновременно.
  Также ограничение при передаче названия функции компонента можно было обойти объявив **именованную стрелочную функцию**, до начала текущего тега, в который передать вызов тега нужного компонента. Например:
```jsx
let SomeComponent = () => <Dialogs />;

const App = (props) => {
  return (
    <div className='app-wrapper'>
        <Route path='/dialogs' component={ SomeComponent } />
    </div>
  )
}
```
#### NavLink
```jsx
import { NavLink } from 'react-router-dom'
```
  Основная задача - поменять `url` в браузере. Является компонентом модуля `react-router-dom`. Нужен для навигации по страницам сайта, используется в связке с `<Route />`. Обязательным атрибутом является `to`, которому присваивается значение `url` страница.  

  Компонент `<Route />` также понимает вложенные `url`, например при урле `/dialogs/spam/blabla` - также будет отображен компонент `/dialogs`. Для отключения такого поведения, используется атрибут `exact`, например `<NavLink to='/dialogs' exact>Profile</NavLink>`. В таком случае данный роут будет отображать компонент только при строгом соответствии пути.
```jsx
const Nav = () => {
  return (
     <ul>
      <li>
        <NavLink to='/profile'>Profile</NavLink>
      </li>
      <li>
        <NavLink to='/dialogs'>Dialogs</NavLink>
      </li>
     </ul>
  )
}
```
  Порядок работы Роутинга следующий:
1. Мы кликаем на компонент `<NavLink />`, на странице сайта она является обычной ссылкой, которая обрабатывается средствами javascript.  
   1. В адрес сайта добавляется `url` ссылки на которую мы кликнули.  
2. Компонент `<Route />` отлавливает изменения в адресной строке и сравнивает новое значение со значением указанным в атрибуте `path`.  
   1. Если оно совпадает, то возвращается содержимое компонента указанного в атрибуте `component`.  
   
  По умолчанию компонент `<NavLink />` активной ссылке добавляет класс `active`. Изменить это можно используя атрибут `activeClassName`.
```jsx
<NavLink to='/profile' activeClassName='activeLink'>Profile</NavLink>
```
## Работа с массивами
React в разметке `jsx` понимает написанный в нём массив, обязательно использовать фигурные скобки `{}`. Если прямо в `jsx` написать переменную содержащую массив из нескольких элементов (строка или реакт-компонент), то компилятор разложит его и отобразит каждый элемент отдельно.
```jsx
const Dialog = (props) => {
  {/* ДАННЫЕ (ДЛЯ ПРИМЕРА НАПИСАНЫ ПРЯМО В КОМПОНЕНТЕ) */}
  let dialogs = [   
    { id: 1, name: 'Dimych' },
    { id: 2, name: 'Slava' },
    { id: 3, name: 'Sasha' },
  ]
  
  {/* ИСПОЛЬЗУЕМ МЕТОД "MAP" ДЛЯ РАБОТЫ С МАССИВАМИ И ФОРМИРУЕМ НОВЫЙ МАССИВ */}
  let dialogsElements = dialogs
    .map( d => <DialogItem name={d.name} id={d.id} );
  
  {/* ВОЗВРАЩАЕМ РАЗМЕТКУ */}
  return (
    <div className="dialogs">
      <div className="dialogsItems">
        { dialogsElements } {/* ВСТАВЛЯЕМ МАССИВ С ЭЛЕМЕНТАМИ В ВИДЕ РЕАКТ КОМПОНЕНТОВ */}
      </div>
    </div>
  )
}
```

## UI - BLL (User Interface - React, Business Logic Layer - Redux)
  UI работает на основе полученных данных (props) и отрисовывает их. Данные в UI приходят не напрямую с сервера, а из прослойки, так называемой Логической (Business Logic). Layer - это слой отвечающий за хранение данных (набор файлов, функций, скриптов и т.д.). За хранение данных в Реакт отвечает Редакс. UI перерисовывается каждый раз когда изменяется состояние (state) в BLL. UI в свою очередь может делать запросы в BLL и изменять его.  
  В реакте реализован принцип Единой ответственности (Single Responsibility Principle (SRP)) - у каждого объекта есть своя ответственность и причина существования и эта ответственность у него только одна. Для этого и существует Редакс и разделение BLL и UI. Нарушение этого принципа является плохим архитектурным решением.  
  
## State
  Это простой объект, который хранит состояние (данные) компонента.  Если состояние изменяется, то компонент перерисовывается. Состояние можно изменять. Изменения могут основываться на ответе от пользователя, новых сообщениях с сервера, ответа сети и т.д. Состояние компонента должно быть приватным для компонента и контролироваться им. Изменения состояния компонента должны происходить внутри компонента - инициализация и обновление.  
  Компонент нуждается в `state`, когда данные в нём со временем изменяются. Например, компоненту `Checkbox` может понадобиться состояние `isChecked`, а компоненту `NewsFeed` необходимо отслеживать посты при помощи состояния `fetchedPosts`.  
  Самая больша разница между `state` и `props` состоит в том, что `props` передаются от родителя потомку, а `state` управляется самим компонентом. Компонент не может изменять `props`, но может изменять `state`.  
  Для каждой отдельной части изменяемых данных должен существовать только один компонент, который "управляет" изменением состояния. Не пытайтесь синхронизировать состояния двух разных компонентов. Вместо этого *поднимите оба этих состояния* до ближайшего компонента-родителя и передайте через пропсы необходим дочерним компонентам.
## onClick, Ref, VirtualDom
#### onClick
  `<button onClick={ () => { alert('Какое-то сообщение...') } }>Add post</button>`. Внутрь `onClick` передается колбэк-функция (функция обратного вызова - предназначенная для отложенного выполнения), в данном случае анонимная, стрелочная. Предпочтительнее такие функции описывать то `render ()`.
```jsx
const MyPost = (props) => {
  let addPost = () => {
    alert('Добавление поста');
  }
  
  return (
    <div className="postsBlock">
      <button onClick={ addPost }>Add post</button>
    </div>
  )
}
```
  При передаче функции в обработчик `onClick` скобки ставить не нужно, иначе функция вызовется немедленно, без события `click`.
#### Ref
  Использование в реакте методов `document.querySelector`, `document.getElementById` и т.д., для получения доступа к элементам на странице и взаимодействия с ними, не целесообразно (хоть и допускается), т.к. реакт на прямую не взаимодействует с DOM, а только лишь через VirtualDom. Для получения ссылки на элемент на странице используется метод `React.createRef()`, который предусматривает добавление атрибута `ref` со значением компоненту. Полный синтаксис использования вместе с `onClick` выглядит следующим образом:
```jsx
const MyPost = (props) => {
  let newPostElement = React.createRef(); { /* ПОЛУЧАЕМ ССЫЛКУ НА ЭЛЕМЕНТ */ }
  
  let addPost = () => {
    let text = newPostElement.current.value; { /* `current` - получение нативного html; `value` - получение значения */ }
    alert(text);
  }
  
  return (
    <div className="postsBlock">
      <textarea ref={ newPostElement }></textarea>
      <button onClick={ addPost }>Add post</button>
    </div>
  )
}
```
  Переменная `let newPostElement`, которой присваивается ссылка на элемент, является объектом DOM, со всеми свойствами.
## Callback через props
  Для того чтобы функцию находящуюся в родительском компоненте вызвать во вложенном компоненте с его параметрами, можно передать его через `props`. Для этого его нужно экспортировать в том компоненте где он описывается.
```jsx
let state = {
  profilePage: {
    posts: [
      { id: 1, message: 'Hi', likesCount: 12 },
      { id: 2, message: 'Hello', likesCount: 21 },
    ]
  }
}

export let addPost = (postMessage) => {
  let newPost = {
    id: 5,
    message: postMessage,
    likesCount: 0
  };
  
  state.profilePage.posts.push(newPost);
}

export default state;
```
## State management
  Вопрос о том как управлять `state`. 
  Один из подходов, это использование локального `state` классового компонента.  
  Есть два варианта с использованием локального `state`, один из них, это создание `state` в каждом из компонентов. Второй это создание `state` в каком-либо родительском файле, значения передавать через `props`, а изменять его с помощью функций. Но большой минус использования такого подхода, это появление большого количества функций для верного его изменения по мере увеличения приложения.  
  Для решения такой проблемы и были придуманы `redux и MobX`. `Redux` - функциональная парадигма программирования, а `MobX` - ООП.
## Инкапсуляция в React
```jsx
let man = {
  { /* 1 */ }
  name: "Dmitry",
  lastName: '',
  sayName() {
    alert(this.name);
  },
  { /* 2 */ }
  _content: '', { /* ПРИВАТНОЕ СВОЙСТВО */ }
  setContent(content) {
    this._content = this.content; // сеттер, срабатывает при записи
  },
  getContent() {
    return this._content; // геттер, срабатывает при чтении
  },
  render: function() {
    document.write(this._content);
  }
}
{ /* 1 */ }
console.log(man.age); { /* ОБРАЩЕНИЕ К СВОЙСТВУ ОБЪЕКТА */ }

man.lastName = 'Kovalchuk' { /* УСТАНОВКА ЗНАЧЕНИЯ СВОЙСТВУ */ }

man.sayName(); { /* ОБРАЩЕНИЕ К МЕТОДУ ОБЪЕКТА */ }

{ /* 2 */ }
man.setContent('Какое-то содержимое...'); { /* Установка нового значения */ }

console.log( man.getContent() ); { /* Получение значения */ }

man.render();
```
  Существует общепринятное правило, что если свойство или метод имеет знак нижнего подчеркивания `_` вначале, то такое свойство или метод являются приватными, а значит не стоит изменять его напрямую, например `man._content = 'Какое-то содержимое...'`. Для изменения таких свойств следует использовать [геттеры и сеттеры](https://learn.javascript.ru/property-accessors). Это свойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта. Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи.
## Store
  Это концепция используемая для распределения состояния между компонентами. В основном это простой объект `JavaScript`, который позволяет компонентам совместно использовать состояние. В нем может храниться как и сам `state`, так и методы работы с ним.
## Dispatch & Action)
  `Dispatch` (пер. Отправка) - это метод объекта `store` для более удобной работы со всеми остальными методами. Он принимает в себя 2 обязательных параметра: `action` и `type` (дополнительных может быть больше), имеет вложенные конструкции `if else`. Используется для изменения состояния `store`.  
  `Action` (пер. Действие) - это стандартный аргумент `dispatch` - объект, у которого обязательно есть свойство `type`, благодаря нему мы можем обрабатывать различные действия по их типу, попадая в нужную секцию `if else`.
```jsx
  // state.js
  let store = {
    _state: '',
    dispatch(action) { // { type: 'ADD-POST' }
      if (action.type === 'ADD-POST') {
        let newPost = {
          id: 5,
          message: this._state.profilePage.newPostText,
        }
      } else if (action.type === 'UPDATE-NEW-POST-TEXT' ) {
        this._state.profilePage.newPostText = action.newText;
        this._callSubscriber(this._state);
      }
    }
  }
  
  // index.js
  <App state={ state } dispatch={ store.dispatch.bind(store) } />
  
  // App.js
  <Route path='/profile' render={ () => <Profile dispatch={ props.dispatch } /> } />
  
  // Profile.js  
  let onPostChange = () => {
    let text = newPostElement.current.value;
    
    props.dispatch({ type: 'UPDATE-NEW-POST-TEXT', text: text });
  }
  
  return (
    <textarea onChange={ onPostChange } ref={ newPostElement } ></textarea>
  )
```
## Action creator, Action type
  Action creator - это функция которая возвращает объект `action` для использования в `dispatch`.
  Action type - это строковая константа, которая записывается в свойство `type` объекта `action`.
```jsx
const ADD_POST = 'ADD-POST';
const UPDATE_NEW_POST_TEXT = 'UPDATE-NEW-POST-TEXT';

// state.js
let store = {
  _state: '',
  dispatch(action) { // { type: 'ADD-POST' }
    if (action.type === ADD_POST) {
      let newPost = {
        id: 5,
        message: this._state.profilePage.newPostText,
      }
    } else if (action.type === UPDATE_NEW_POST_TEXT ) {
      this._state.profilePage.newPostText = action.newText;
      this._callSubscriber(this._state);
    }
  }
}

export const addPostActionCreator = () => {
  return {
    type: ADD_POST
  }
}

export const updateNewPostTextActionCreator = (text) => {
  return {
    type: UPDATE_NEW_POST_TEXT,
    newText: text
  }
}

// Profile.js
import { addPostActionCreator, updateNewPostTextActionCreator } from './../...state.js';

let addPost = () => {
  props.dispatch( addPostActionCreator() );
}

let addPost = () => {
  let text = newPostElement.current.value;
  
  props.dispatch( updateNewPostTextActionCreator( text ) );
}
```
## Reducer
  Это чистая функция которая принимает `state` и `action`, если нужно применяет этот `action` к `state` и возвращает новый `state`, либо неизмененный `state`.
```jsx
reducer(state, action) {
  ...
  return changedState;
}
```
  После возвращения нового `state`, "подписчики" будут уведомлены о изменениях в `state` и смогут запросить изменения с помощью `getState`.
## Redux
```bash
npm install redux --save
```
  В `redux` по умолчанию есть функция по созданию `store`. Также `redux` по умолчанию уведомляет своих подписчиков об изменении `state`, но не передает им `state`. Для этого требуется с вызовом функции рендеринга DOM дерева передавать ей `state` в параметрах.
```jsx
// index.js
let rerenderEntireTree = (state) => {
  ReactDOM.render(
    <BrowserRouter>
      <App state={state} dispatch={store.dispatch.bind(store)} store={store} />
    </BrowserRouter>, document.getElementById('root'));
  )
}

rerenderEntireTree(store.getState()); // ПОЛУЧАЕМ STATE С ПОМОЩЬЮ ВСТРОЕННОГО МЕТОДА REDUX

// УВЕДОМЛЕНИЕ ПОДПИСЧИКОВ ПРИ ИЗМЕНИИ STATE
store.subscribe(() => {
  let state = store.getState();
  rerenderEntireTree(state);
})
```
  В переменную `reducers` записываются `state` в качестве названия свойства объекта и сами `reducers` в качестве значений.
```jsx
// redux.js
import { combineReducers, createStore } from "redux";
import profileReducer from "./profile-reducer";
import dialogsReducer from "./dialogs-reducer";
import sidebarReducer from "./sidebar-reducer";

let reducers = combineReducers({
  profilePage: profileRecuder,
  dialogsPage: dialogsReducer,
  sidebar: sidebarReducer
});

let store = createStore(reducers);

export default store;
```
## Container component
  Это **контейнерная компонента** которая является оберткой над комопнентом. Может не удовлетворять требованиям чистой функции. Она будет получать в себя `store`, а также проводить все манипуляции с ним, для дальнейшей передачи в **презентационную компоненту**.
```jsx
// App.js
<Route render = { () => <DialogsContainer store={ props.store } /> } />
////

// DialogsContainer.jsx
import Dialogs from './Dialogs.js';

const DialogsContainer = (props) => {
  let onNewMessageChange = (body) => {
    props.state.dispatch(updateNewMessageBodyCreator(body));
  }
  
  return <Dialogs updateNewMessageBody={ onNewMessageChange } />
}

export default DialogsContainer;
////

// Dialogs.js
let onNewMessageChange = (e) => {
  let body = e.target.value;
  props.updateNewMessageBody(body);
}
////
```
  То есть для `render` мы уже передаем компонент `DialogsContainer`, в него же передаем `props`, проводим все манипуляции с ним и возвращем компонент `Dialogs`.
## Контекст
  Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях. Контекст разработан для передачи данных, которые можно назвать "глобальными" для всего дерева Реакт-компонентов (например, текущий текущий аутентифицированный пользователь, UI-тема или выбранный язык).  
  Обычно контекст используется, если необходимо обеспечить доступ данных во *многих* компонентах на разных уровнях вложенности. По возможности не стоит его использовать, так как это усложняет повторное использованиекомпонентов.
> Если необходимо избавиться от передачи нескольких пропсов на множество уровней вниз, обычно **[композиция компонентов](https://ru.reactjs.org/docs/composition-vs-inheritance.html)** является более простым решением, чем контекст.  

  Для использования контекста его нужно создать с дефолтным значением `const MyContext = React.createContext(defaultValue);`. Далее копмонент должен создать `Provider` (поставщик) и передать в него значение `< MyContext.Provider value={ /* store value */ } />`. Дочерний компонент принимает контекст и яляется `Consumer` (потребителем) `<MyContext.Consumer> { value } </MyContext.Consumer>`.
```jsx
// DialogsContainer.js
const DialogsContainer = () => {
  return <StoreContext.Consumer>
  {
    (store) => {
      let onNewMessageChange = (body) => {
        store.dispatch(updateNewMessageBodyCreator(body));
      }

      return <Dialogs updateNewMessageBody={ onNewMessageChange } />
    }
  }
  </StoreContext.Consumer>
}
```
## React-redux
  Прослойка для эффективного взаимодействия между реактом и редаксом. Для каждой презентационной компоненты тербуются колбэки и данные из стэйта. Данная библиотека позволяет удобно создавать контейнерные компоненты, для передачи в презентационные компоненты необходимые для её работы данные.
  `connect(f1, f2)(Dialogs)` - такая запись будет означать, что результат первого вызова функции будет передан в качестве параметров во второй вызов этой же функции.  Функция для передачи колбэков по документации и общепринятому наименованию называется `mapDispatchToProps`, а функция для передачи стэйта `mapStateToProps`.
## Deep copy vs Shallow copy
  Глубокая копия против поверхностной. Речь идет о копировании объектов. Когда говорят об объявлении объектов с помощью *литерала* подразуемается объект который был объявлен с использованием фигурных скобок `{}`.
  > Аналогичное правило справедливо и при создании массиво с помощью квадратных скобок `[]`.  
  
  Объекты вложенные в друг друга с точки зрения синтаксиса написания, на самом деле не являются вложенными и являются независимыми, а в объекты вкладываются ссылки на них. При объявлении нового объекта и присвоения ему значения другого объекта, напимер `var b = { ...a }`, то в переменную `b` копируются только непосредтсвенные значения объекта `a`, вложенные объекты не копируются, а лишь добавляются ссылки на них. Поэтому при обращении к вложенным объектам из объекта `b` с помощью сеттера и изменения их значений, они также изменятся и для объекта `a`, в котором также находятся лишь ссылки на эти же объекты.  
  Два объекта никогда не могут быть равны, даже если они будут абсолютно единтичны, т.к. в них лежать разные ссылки.  
  По настоящему копировать содержимое объекта из одного в другой все таки можно, используя оператор `spread`: `b.classroom.teacher = { a.classroom.teacher }`. Теперь изменения значения объекта `teacher` в объекте `b` не затронут аналогичный объект в объекте `a`.  
  Если в объектах есть примитивы (строки, числа, булевы значения), то их значения сравниваются по значениям и соответсвенно они могут быть равны. Чтобы сделать копию содержимого массива, следует воспользоваться следующей конструкцией:
```jsx
  let stateCopy = {
    ...state,
    users: [...state.users]
  }
```
## Детерминированность
  В реакте это означает что при одних и тех же пропсах наша функциональная компонента должна возвращать одинкавый jsx. Это же касается Редьюсеров, при одинаковвых `state` и `action` она должна возвращать нам одинаковый `state`. При поступлении в редьюсер стэйта, нам необходимо сделать его копию, т.к., как описано в главе про копирование объектов, в приходящем стэйте лежит ссылка на оригинальный объект и при изменеии его в редьюсере, мы изменим его глобально.
## Rest API
  **Application Programm[-ing] Interface** - интерфейс взаимодействия с программой.  
  **Server API** - интерфейс взаимодействия с сервером.  
  Server API состоит из нескольких составных частей:  
  1. Hardware (непосредственно сервер)  
  2. Software (программное обеспечение) - Apach (php), NodeJS (js), IIS (c#), Django (Pyton) etc.  
  3. Endpoint (сам API)  
    1. URL: "https://samuraiJS.com/api/users"  
    2. http-request type: get / post  
    3. request payload  
    4. response data  
    5. http codes: 404 - not found, 5XX - server errors, 3XX - redirect, 2XX - OK  
  **SERVER REST API** - GET - POST - PUT - DELETE (CRUD) - CreateReadUpdateDelete  
  > http-request type: get / post / put / delete / patch  
## Axios
`import * as axios from 'axios'`.  
  Звездочка при импорте означает что нужно импортировать все что экспортируется из данной библитеки под общую переменную.
  `axios` - библиотека для работы с REST API, чтобы делать удобные запросы на сервер.
```jsx
  axios.get("https://social-network.samuraijs.com/api/1.0/users ")
    .then(response => {
      props.setUsers();
    })
```
## Классовый компонент
  Это класс который наследуется `React.Component` и которого как минимум есть метод `render`, который возвращает `jsx`.
  Класс нужны чтобы штопать однотипные объекты. Внутри класса есть конструктор, который принимает параметры.
```jsx
  class Man {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }
```
  Каждый вызов класса с ключевым словом `new` и передачей параметров, создаст новый объект с значениями в соответствии с переданными параметрами.
```jsx
  let m1 = new Man('Dima', 31);
```
  Получается это второй способ создания объектов (первый способ это использование литерала объектов `{}`) - использование конструктора класса.  
  При использовании классов в реакт, он аналогично функциональному компоненту не вызывается сразу, его затем вызывает сам реакт. Использование классов в `jsx` аналогично функциональному компоненту, `<Man name="samurai" age={31} />`.
```jsx
  class Man extends React.Component {
    constructor(props) {
      super(props);
    }
    render() {...}
  }
```
  `extends` - означает что данный класс наследует методы от реакта. Внутри классовых компонентов нельзя объявлять обычные функции, их стоит записывать как методы объекта.
## Life cycle methods
  У любого класса React.Component есть два метода `componentDidMount() && componentDidUpdate()`. **componentDidMount** это как раз то место где стоит делать все `side effect`, ajax запросы и т.д. Перед тем как компонент будет убран со страницы, то есть демонтирован, вызывается **componentWillUnmount**.
  ```jsx
  class Man extends React.Component {
    componentDidMount() {
       axios.get("https://social-network.samuraijs.com/api/1.0/users ")
        .then(response => {
          this.props.setUsers(response.data.items);
        });
    }
  
    render() {...}
  }
```
## Презентационная и контейнерная компонента
  *Презентационная компонента* принимает пропсы и возвращает jsx. *Контейнерная компонента* - назначение, общаться со store, с помощью connect. [Презентация](https://app.creately.com/diagram/axNrLMIOyaP/edit)
## Cookie, login, auth
  По умолчанию браузер при каждом запросе на сервер автоматически крепит к ним cookie. Куки передаются в зашифрованном виде, для того чтобы избежать возможности их скомпрометировать. После отправления куки удаляются. За исключением того случая, когда мы поставили галочку "запомнить меня на этом компьютере".
## DAL
  Data access layer - слой доступа к данным.
  Это прослойка между UI и API. К нему относится `axios`.
## Redux Thunk
  `yarn add redux-thunk`.  
  Это библиотека для реализации удобного обращения к серверу. Таким образом в процесс работы приложения кроме UI и BLL входит еще и DLL. На нем организуется работа с API запросами.
> Это функция которая делает асинхронную операцию и которая умеет диспатчить обычные action и саму thunk тоже можно задиспатчить.
## HOC - High Order Component
  > Не возвращает `jsx`.  
  Один и з способов повторного использования логики.
  Это простая функция, которая принимат компонент и возвращает контейнерную компоненту.
## HTTP
#### get, delete
  Они не могут ничего передать на сервер кроме `url` адреса. Для передачи можно использовать `query` (`url/{userId}`) или `uri` параметры (`?city=minsk`).
#### post, put
  `post` - создание, `put` - обновление.
## componentDidUpdate
  Имеет доступ к предыдущему `state` и `props`.
## react-logger
## redux-form || formik
  1. Выносин в отдельную компонету форму
  2. Вешаем `handleSubmit` в качестве обработчика `submit`
  3. Вместо инпутов устанвливаем `<Field />`
  4. Оборачиваем `redux-form`
## Reselect
  Это библиотека для создания мемоизированных селекторов (memoized selectors). Мы определяем селекторы как функции, извлекающие фрагменты состояния Redux для наших компонентов React. Используя мемоизацию, мы можем предотвратить ненужные перерисовки и пересчеты полученных данных, что, в свою очередь, ускорит наше приложение.
## Hooks
  Это функции, с помощью которых можно "подцепиться" к состоянию и методам цикла React из функциональных компонентов. Хуки не работают внутри классов - они дают возможность использовать React без классов. React сожержит несколько встроенных хуков. таких как `useState`.  
  Их запрещено использовать в условиях и циклах.
#### useState - Хук состояния
  `const [state, setState] = useState(initialState);`
  Возвращает значение с состоянием и функцию для его обновления. Во время первоначального рендеринга возвращаемое состояние (`state`) совпадает со значением, переданным в качестве первого аргумента (`initialState`).  
  Функция `setState` используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента `setState(newState)`.  
  Во время последующих повторных рендеров первое значение, возвращаемое `useState`, всегда будет самым последним состоянием после применения обновлений.
###### Функциональное обновление
  Если новое состояние вычисляется с использованием предыдущего состояния, можно передать фукнцию в `setState`. Функция получит предыдущее значение и вернёт обновлённое значение.
```jsx
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Счёт: {count}
      <button onClick={() => setCount(initialCount)}>Сбросить</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </>
  );
}
```
> Обрати внимание, что зарезервированным словом тут является только `useState`. Результат выполнения данного хука с помощью деструктуризации присваивается 2 переменным. В 1-ой переменной будет храниться текущее состояние, а во второй функция для его обновления.  

  Если функция обновления возвращает абсолютно такой же результат как и текущее состояние, то все последующие повторные рендеры будут полностью пропущены.
###### Ленивая инициализация состояния
  Аргумент `initialState` - это состояние, используемое во время начального рендеринга. В последующих рендерах это не учитывается. Если начальное состояние дорого вычислять постоянно, то можно предоставить функцию, которая будет выполняться только при начальном рендеринге:
```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```
###### Досрочное прекращение обновления состояния
  Если обновить состояние хука тем же значением, что и текущее состояние, React досрочно выйдет из хука без повторного рендера дочерних элементов и запуска эффектов.
#### useEffect - Хук эффекта
  Это хук с помощью которого мы можем выполнять побочные эффекты из функционального компонента. Он выполянет ту же роль, что и `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в React классах, объединив их в единый API.
```jsx
// По принципу componentDidMount и componentDidUpdate:
useEffect(() => {
  // Обновляем заголовок документа, используя API браузера
  document.title = `Вы нажали ${count} раз`;
});  
```
  Когда мы вызывам `useEffect`, React получает указание запустить нашу функцию с "эффектом" после того, как он отправил изменения в DOM. Поскольку эффекты обновляются внутри компонента, у них есть доступ к его пропсам и состоянию. По умолчанию, React запускает эффекты после каждого рендера, *включая* первый.
  При необходимости можно вернуть из эффекта функцию, которая указывает эффекту, как выполнить за собой "сброс".
```jsx
useEffect(() => {
  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
  };
});
```
 Например, этот компонент использует эффект, чтобы подписаться на статус друга в сети, и выполняет сброс, отписываясь от него. React будет отписываться от нашего `ChatAPI` перед тем, как компонент размонтируется и перед тем, как перезапустить эффект при повторном рендере. Вы можете сделать так, чтобы React пропускал повторные подписки если `props.friend.id`, который мы передали в `ChatAPI`, остался без изменений.  
> Короче, компонент сначала выполнится, потом вернет `jsx`, встроит его на страницу, а потом уже выполнит `useEffect`. То есть компонента теперь кроме `jsx` возвращает еще и функции, которые должны быть выполнены.
```jsx
const ProfileStatusWithHooks = (props) => {
  let [editMode, setEditMode] = useState(false);
  let [status, setStatus] = useState(props.status);
  
  useEffect( () => {
    setStatus(props.status);
  }, [props.status]) // зависимость
  
  return (
    // ... jsx
  )
}
```
  В данном случае хук `useEffect` выполниться лишь раз после рендеринга компонента. Но стоит также передать вторым аргументом "зависимость", которая укажет на то что нужно также запускаться после каждого изменения в статуса приходящего нам в `props`.
## React.PureComponent
  Похож на `React.Component`. Отличие заключается в том, что `React.Component` не реализует `shouldComponentUpdate()`, а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.  
  Если метод `render()` вашего React-компонента всегда рендрит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях можно использовать `React.PureComponent`.
## React.memo
  `React.memo` - это *компонент высшего порядка*. Он похож на `React.PureComponent`, но предназначен для фукнциональных компонентов.  
  Если функциональный компонент всегда рендерит одинаковый результат для одних и тех же пропсов, можно обернуть его в вызов `React.memo` для повышения производительности в некоторых случаях, мемоизируя  результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.  
  `React.memo` затрагивает только изменения пропсов. Если функциональный компонент обёрнут в `React.memo` и использует `useState` или `useContext`, он будет повторно рендериться при изменении состояния или контекста.
## Pure function
  1. **Immutability** - не изменяет параметры которые ей приходят.
  2. Возвращает результат
  3. No side-effect - не имеет побочных эффектор
  4. Детерминированновсть - на одни и те же данные функция будет возвращать один и тот же результат.
## Redux ducks - масштабирование Redux-приложения
  [Пример структуры проекта построенного по принципу re-ducks](https://github.com/FortechRomania/react-redux-complete-example)  
  Сейчас есть два общепринятых подхода к организации приложений: `function-first` и `feature-first`.  
  `function-first` - означает, что ваши каталоги верхнего уровня называются в соответствии с файлами внутри. например: `containers, components, actions, reducers` и т.д.  Такое вообще не масштабируется. По мере роста приложения и появления нового функционала, нужно будет добавлять файлы в те же папки. Еще одна проблема заключается в объединении папок. Один из потоков вашего приложения, вероятно, потребует доступ к файлам из всех папок. Одним из преимуществ этого подхода является то, что он умеет изолировать, в нашем случае React от Redux.  
  `feature-first` значит, что каталоги верхнего уровня будут называться в соответствии с основным функционалом приложения: `product, cart, session`. Такой подход гораздо лучше масштабируется, поскольку каждая новая фича лежит в новой папке. Однако у вас нет разделения между компонентами Redux и React. Изменение в одном из них в долгосрочной перспективе - задача непростая. Помимо этого, будут файлы, которые не будут относиться ни к одной из функции. В итоге все сведется к папке `common` или `shared`.  
  **re-ducks** - решение состоит в разделении на duck-папки:
```
duck/
├── actions.js
├── index.js
├── operations.js
├── reducers.js
├── selectors.js
├── tests.js
├── types.js
├── utils.js
```
  Duck-папка должна:
  - Содержать всю логику обработки только ОДНОГО концепта приложения, например: product, cart, session и т.д.
  - Содержать файл index.js, который экспортируется в соответствии с правилами duck.
  - Хранить в одном файле код, который выполняет аналогичную, например reducers, selectors и actions.
  - Содержать тесты, относящиеся к duck.  
  Содержание каждого файла.  
  #### Types
  Файл *types* содержит имена *actions*, которые выполняются в приложении. В качестве хорошей практики, нужно пытаться охватить область имен, соответсвующую функции, который они принадлежат.
```jsx
const QUACK = "app/duck/QUACK";
const SWIM = "app/duck/SWIM";

export default {
    QUACK,
    SWIM
};
```
#### Actions
  В этом файле содержатся все функции *action creator*. Все *action* должны быть представлены фукнциями, даже если она не параметризованы.
```jsx
import types from "./types";

const quack = ( ) => ( {
    type: types.QUACK
} );

const swim = ( distance ) => ( {
    type: types.SWIM,
    payload: {
        distance
    }
} );

export default {
    swim,
    quack
};
```
#### Operations
  Для представления цепных операций понадобится redux *middleware*, чтобы улучшить функцию *dispatch* (redux-thunk, redux-saga или redux-observable).  
  Если операция отправляет только один action, то есть фактически не использует redux-thunk, мы пересылаем функцию action creator. Если операция использует thunk, она может отправить много actions и связать их с помощью promises.
```jsx
import actions from "./actions";

// This is a link to an action defined in actions.js.
const simpleQuack = actions.quack;

// This is a thunk which dispatches multiple actions from actions.js
const complexQuack = ( distance ) => ( dispatch ) => {
    dispatch( actions.quack( ) ).then( ( ) => {
        dispatch( actions.swim( distance ) );
        dispatch( /* any action */ );
    } );
}

export default {
    simpleQuack,
    complexQuack
};
```
#### Reducers
  Если имеется более многогранная функция, определенно стоит использовать несколько *reducers* для обработки сложных структур состояний. Помимо этого, не стоит бояться использоваь столько *combineReducers*, сколько нужно.
```jsx
import { combineReducers } from "redux";
import types from "./types";

/* State Shape
{
    quacking: bool,
    distance: number
}
*/

const quackReducer = ( state = false, action ) => {
    switch( action.type ) {
        case types.QUACK: return true;
        /* ... */
        default: return state;
    }
}

const distanceReducer = ( state = 0, action ) => {
    switch( action.type ) {
        case types.SWIM: return state + action.payload.distance;
        /* ... */
        default: return state;
    }
}

const reducer = combineReducers( {
    quacking: quackReducer,
    distance: distanceReducer
} );

export default reducer;
```
#### Selectors
  Селекторные функции берут срез состояния приложения и возвращают на его основе некоторые данные. Они никогда не вносят изменения в состояние приложения.
```jsx
function checkIfDuckIsInRange( duck ) {
    return duck.distance > 1000;
}

export default {
    checkIfDuckIsInRange
};
```
#### Index
  Этот файл указывает на то что будет экспортироваться из duck-папки. Он:
  - экспортирует фукнцию *reducer* из duck по умолчанию.
  - эспортирует в виде именных экспортов селекторы и операции.
  - экспортирует типы, если они требуются в других duck'ах.
```jsx
import reducer from "./reducers";

export { default as duckSelectors } from "./selectors";
export { default as duckOperations } from "./operations";
export { default as duckTypes } from "./types";

export default reducer;
```
#### Tests
  Преимущество использования Redux вместе со структурой ducks состоит в том, что можно писать тесты прямо после кода, который нужно протестировать.
```jsx
import expect from "expect.js";
import reducer from "./reducers";
import actions from "./actions";

describe( "duck reducer", function( ) {
    describe( "quack", function( ) {
        const quack = actions.quack( );
        const initialState = false;

        const result = reducer( initialState, quack );

        it( "should quack", function( ) {
            expect( result ).to.be( true ) ;
        } );
    } );
} );
```
  Вунтри этого файла можно писать файлы для `reducers, operations, selectors etc.`.
## Тестирование компонентов
  Необходимо уметь тестировать компонент в отрыве от бизнеса.  
  `Jest` это среда запуска тестов.  
  `react-test-renderer`.
## React.Lazy и React.Suspense
  Используется для ленивой дозагрузки компонентов.
`const DialogsContainer = React.lazy( () => import('./components/Dialogs/DialogsContainer'));`
  Компонент будет загружен только при запросе на данный компонент. В итоговый `bundle` он не попадет. А саму компоненту необходимо завернуть `suspense`:
```jsx
<React.Suspense fallback={<div>Loading...</div>}>
  <DialogsContainer />
</React.Suspense>
```
  В параметре `fallback` указывается разметка, которая будет показываться пока компонент не будет загружен.
## Хостинг React приложения - Github Pages
  Github pages не является полноценным хостингом, поэтому не достаточно просто закинуть в репозиторий папку `build` своего проекта.  
  1. Установить пакет **gh-pages**:  
  `yarn add gh-pages --dev`  
  2. Необходимо внести правки в наш `package.json`: 
  ```jsx
  //...
  "homepage": "http://gitname.github.io/react-gh-pages"
  ```
На нашем репозитории теперь будут две главные ветки: `master` и `gh-pages`. Ветка `master` будет обращаться к каталогу `src`, а `gh-pages` к файлам специально скомпилированным для хостинга на github.
## Router switch
  Для предотвращения неверной работы роутов, стоит использовать компонент `<Switch />`, которым необходимо завернуть наши `<Route />`. В таком случае переход по нашим роутрам будет происходить сверху вниз и при первом найденном совпадении, дальнейшие роуты не будут учтены.  
  Для добавления 404 страницы нужно добавить данный роутер в самый конец списка:
```jsx
<Switch>
  <Route exact path="/" render={ () => <Redirect to={'/profile'} /> } />
  <Route path="/dialogs" render={withSuspense(DialogsContainer)} />
  <Route path="/profile/:userId?" render={withSuspense(ProfileContainer)} />
  
  <Route path="*" render={ () => {<div>404 not found</div>} } />
</Switch>
```
## Classnames
  Для добавления классов элементам при использовании css модулей следует импортировать переменную из файла стилей, а в компоненте использовать данную переменную и обращаться к классам через точечную нотацию.
```jsx
import classes from './Paginator.module.css';

<div className={styles.paginator}>...</div>
```
Для добавления нескольких классов к одному компоненту необходимо использовать конкатенацию строк:  
```jsx
<div className={styles.paginator + ' ' + styles.selectedPage}>...</div>
```
Или использовать шаблонную строку:  
```jsx
<div className={`${styles.paginator} ${styles.selectedPage}`}>...</div>
```
Но лучшим решением будет использование библиотеки [classnames](https://www.npmjs.com/package/classnames).
